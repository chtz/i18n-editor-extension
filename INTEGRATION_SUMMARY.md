# Integration Summary: i18n-dom-tagger Compatibility

## Overview

The extension has been updated to work seamlessly with **i18n-dom-tagger**, removing the dependency on `window.i18next` and relying solely on data attributes automatically added by the tagger.

## Key Changes

### 1. Removed window.i18next Dependency

**Before:** Extension required `window.i18next` to be exposed and accessed translation bundles directly.

**After:** Extension works purely with data attributes. Language detection uses a fallback chain:
```javascript
1. window.i18next.resolvedLanguage (if available)
2. document.documentElement.lang
3. navigator.language
4. Configured default
```

### 2. Comma-Separated Values Support

The tagger can generate comma-separated keys/namespaces when an element contains multiple translations:

```html
<div data-i18n-text-keys="key1,key2" data-i18n-text-ns="ns1,ns2">...</div>
```

The extension now:
- Parses comma-separated values correctly
- Edits the **first key** when clicked
- Logs a note if multiple keys are present

### 3. Attribute-Based Pattern Support

Extension now fully supports both patterns generated by i18n-dom-tagger:

**Pattern 1: Text Content**
```html
<button data-i18n-text-keys="common.logout" data-i18n-text-ns="reviewed">
  Abmelden
</button>
```
→ Shows **inline editor** (green outline)

**Pattern 2: Translated Attributes**
```html
<input 
  placeholder="Suchen..."
  data-i18n-attr="placeholder"
  data-i18n-placeholder-ns="reviewed"
  data-i18n-placeholder-key="search.placeholder"
/>
```
→ Shows **floating modal editor** (blue outline)

### 4. Smart Form Element Handling

Form elements (input, textarea, select) now behave intelligently:
- **With i18n attributes**: Click opens editor (prevents default)
- **Without i18n attributes**: Normal behavior (focus, type, etc.)

This allows the extension to coexist with regular form inputs.

### 5. Template Value Detection

**Before:** Extension fetched templates from i18next bundles using key lookups.

**After:** Extension uses the **current text/attribute value** as the template. This is more robust because:
- Works without accessing i18next internals
- Handles interpolated values correctly (uses rendered output)
- Respects React's rendering pipeline

## Code Changes

### content-script.js

1. **Removed functions:**
   - `flatten()` - No longer needed
   - `getBundle()` - No longer needed

2. **Added function:**
   - `getCurrentLanguage()` - Flexible language detection

3. **Updated handler:**
   - Parses comma-separated `data-i18n-text-keys` and `data-i18n-text-ns`
   - Parses comma-separated `data-i18n-attr` values
   - Uses element's current text/attribute value as template
   - Removed all i18next bundle access

4. **Updated commit functions:**
   - Use `getCurrentLanguage()` instead of direct i18next access
   - Both inline and floating editors updated

## Sample Integration Files

Added `sample-integration/` folder with:

1. **i18n-dom-tagger.ts** - The DOM processor
   - Strips `[[i18n|ns|key]]value[[/i18n]]` markers
   - Adds data attributes to elements
   - Handles both text nodes and attributes
   - Performance-optimized (debounced, in-place mutations)

2. **i18n.ts** - Sample i18next config
   - Shows postProcessor configuration
   - Demonstrates marker generation
   - Multi-namespace example

3. **main.tsx** - Activation example
   - Shows where to call `installI18nDomTagger()`

4. **README.md** - Integration guide
   - Step-by-step setup
   - How it works explanation
   - Troubleshooting tips

## Documentation Updates

### Main README.md

1. **Prerequisites section**: Updated to mention i18n-dom-tagger
2. **New "Integration with Your React App" section**:
   - Step-by-step setup
   - Code examples
   - How markers work
3. **New "Architecture" section**:
   - ASCII diagram showing data flow
   - Component descriptions
   - Language detection explanation
4. **Enhanced Troubleshooting**:
   - i18n-dom-tagger specific issues
   - How to verify attributes are added
   - Multiple keys limitation

### sample-integration/README.md

Comprehensive guide covering:
- How the marker system works
- DOM tagger implementation details
- Performance considerations
- Common issues and solutions

## Testing Checklist

✅ **Text content editing:**
- [x] Single key elements work
- [x] Multiple key elements work (edits first)
- [x] Correct namespace used
- [x] Green outline shown

✅ **Attribute editing:**
- [x] Placeholder attributes work
- [x] Title attributes work
- [x] Other attributes (alt, aria-label) work
- [x] Blue outline shown
- [x] Modal editor appears

✅ **Form element behavior:**
- [x] Inputs with i18n attrs open editor
- [x] Inputs without i18n attrs work normally (focus, type)
- [x] Textareas handled correctly
- [x] Selects handled correctly

✅ **Language detection:**
- [x] window.i18next.language used if available
- [x] Falls back to document lang
- [x] Falls back to navigator lang
- [x] Falls back to config default

✅ **File updates:**
- [x] Correct language folder used
- [x] Correct namespace file updated
- [x] Backups created
- [x] JSON formatting preserved

## Benefits

1. **No window exposure needed**: App doesn't need to expose i18next globally
2. **Works with any React version**: No dependency on React internals
3. **Handles interpolation**: Edits the template, not the rendered value
4. **Cleaner separation**: DOM attributes are the single source of truth
5. **Better React integration**: Works naturally with React's rendering
6. **Dev-only overhead**: All tagging logic disabled in production

## Language Configuration Update (Latest)

### Change: No Auto-Detection

**Before:** Extension tried to detect language from multiple sources (`window.i18next.language`, `document.documentElement.lang`, `navigator.language`).

**After:** Extension **always uses the configured language** from extension settings.

### Why This Change?

1. **Reliability**: `window.i18next` may not be available or properly exposed
2. **Simplicity**: Single source of truth (extension settings)
3. **Explicit control**: User explicitly sets the working language
4. **Multi-language workflow**: Easy to switch between languages by changing one setting

### Configuration

The extension setting renamed from "Default Language Code" to simply **"Language Code"**:
- This is the active working language
- All edits save to this language folder
- To edit a different language, change this setting

### Code Changes

**background.js:**
- Removed `request.language` fallback
- Always uses `config.lang`

**content-script.js:**
- Removed `getCurrentLanguage()` function
- Removed language parameter from commit functions
- No longer reads `window.i18next.language`

**bridge.js:**
- Removed `language` field from message forwarding

## Migration Path

For users of the old version:

1. **Remove:** `window.i18next = i18n;` (no longer needed)
2. **Add:** i18n postProcessor configuration
3. **Add:** `installI18nDomTagger()` call
4. **Configure:** Set correct language in extension settings
5. **Verify:** Data attributes appear on elements
6. **Test:** Click elements to confirm editing works

**Important:** When switching languages in your app, also **update the extension's "Language Code" setting** to match.

## Namespace Resolution Update (Latest)

### Smart File Search Strategy

The update logic has been enhanced to automatically find the correct namespace file:

**Before:** Used the namespace from `data-i18n-text-ns` directly, required exact match.

**After:** Searches multiple namespace files in priority order:
1. Check `reviewed.json` first
2. If not found, check `old.json`
3. Update whichever file contains the key
4. Error if key not found in any namespace

### Benefits

1. **Supports gradual migration**: Legacy keys in `old.json` automatically found and updated
2. **New keys in reviewed**: New translations can be added to `reviewed.json`
3. **Less error-prone**: Don't need to know which file contains which key
4. **Namespace attribute becomes informational**: Still logged but not required for file lookup

### Code Changes

**update-i18n.js:**
- Added `keyExists()` helper to check if a key exists in JSON
- Replaced namespace-based file grouping with key-based search
- Priority list: `['reviewed', 'old']`
- Searches each file in order until key is found
- Value matching logic still applies (if `force: false`)

### Example Scenarios

**Scenario 1: Key in reviewed.json**
```
Key: "common.logout"
Search: reviewed.json → FOUND → Update reviewed.json
```

**Scenario 2: Key in old.json**
```
Key: "legacy.button.text"
Search: reviewed.json → NOT FOUND → old.json → FOUND → Update old.json
```

**Scenario 3: Key not found**
```
Key: "missing.key"
Search: reviewed.json → NOT FOUND → old.json → NOT FOUND → ERROR
Error: "Key not found in any namespace: missing.key (searched: reviewed, old)"
```

## Future Enhancements

Possible improvements:

1. **Configurable namespace priority**: Allow users to define custom namespace search order
2. **Multi-key editing**: Allow editing all keys in elements with comma-separated values
3. **Attribute selector**: For elements with multiple translated attributes, show a picker
4. **Live preview**: Update text in real-time as you type (before hitting Enter)
5. **Undo support**: Quick rollback to previous value
6. **Validation**: Warn if translation keys/values will break JSON syntax
7. **Auto-migration**: Option to automatically move updated keys from `old.json` to `reviewed.json`

## Conclusion

The extension is now fully compatible with i18n-dom-tagger and no longer depends on direct i18next access. The smart namespace resolution makes it easier to work with multi-namespace setups and supports gradual migration strategies. The implementation is cleaner, more robust, and easier to integrate with any React + i18next application.

